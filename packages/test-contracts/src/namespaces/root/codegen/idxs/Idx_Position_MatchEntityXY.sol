// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

// Import store internals
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";

// Import idx internals
import { Uint8Map, Uint8MapLib } from "@dk1a/mud-table-idxs/src/Uint8Map.sol";
import { hashIndexes, hashValues } from "@dk1a/mud-table-idxs/src/utils.sol";

import { registerBasicIdx } from "@dk1a/mud-table-idxs/src/namespaces/basicIdx/registerBasicIdx.sol";
import { BasicIdx } from "@dk1a/mud-table-idxs/src/namespaces/basicIdx/codegen/tables/BasicIdx.sol";
import { BasicIdxUsedKeys } from "@dk1a/mud-table-idxs/src/namespaces/basicIdx/codegen/tables/BasicIdxUsedKeys.sol";
import { BasicIdx_KeyTuple } from "@dk1a/mud-table-idxs/src/namespaces/basicIdx/BasicIdx_KeyTuple.sol";

library Idx_Position_MatchEntityXY {
  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: "", name: "Position", typeId: RESOURCE_TABLE });`
  ResourceId constant _tableId = ResourceId.wrap(0x74620000000000000000000000000000506f736974696f6e0000000000000000);

  uint256 constant _keyNumber = 1;
  uint256 constant _fieldNumber = 2;

  Uint8Map constant _keyIndexes = Uint8Map.wrap(0x0100000000000000000000000000000000000000000000000000000000000000);
  Uint8Map constant _fieldIndexes = Uint8Map.wrap(0x0200010000000000000000000000000000000000000000000000000000000000);

  bytes32 constant _indexesHash = 0xdd16a3ea36bb9c7349b37aef764e53367f0ec93200c9a812fff143fcffe0c8d5;

  function valuesHash(bytes32 matchEntity, int32 x, int32 y) internal pure returns (bytes32) {
    bytes32[] memory _partialKeyTuple = new bytes32[](_keyNumber);

    _partialKeyTuple[0] = matchEntity;

    bytes[] memory _partialValues = new bytes[](_fieldNumber);

    _partialValues[0] = abi.encodePacked((x));

    _partialValues[1] = abi.encodePacked((y));

    return hashValues(_partialKeyTuple, _partialValues);
  }

  // Should be called once in e.g. PostDeploy
  function register() internal {
    registerBasicIdx(_tableId, _keyIndexes, _fieldIndexes);
  }

  function length(bytes32 matchEntity, int32 x, int32 y) internal view returns (uint256) {
    bytes32 _valuesHash = valuesHash(matchEntity, x, y);

    return BasicIdx_KeyTuple.length(_tableId, _indexesHash, _valuesHash);
  }

  function hasKeyTuple(bytes32[] memory _keyTuple) internal view returns (bool _has, uint40 _index) {
    bytes32 _keyTupleHash = keccak256(abi.encode(_keyTuple));

    return BasicIdxUsedKeys.get(_tableId, _indexesHash, _keyTupleHash);
  }

  function has(bytes32 matchEntity, bytes32 entity) internal view returns (bool _has, uint40 _index) {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = matchEntity;
    _keyTuple[1] = entity;

    return hasKeyTuple(_keyTuple);
  }

  function getKeyTuple(
    bytes32 matchEntity,
    int32 x,
    int32 y,
    uint256 _index
  ) internal view returns (bytes32[] memory _keyTuple) {
    bytes32 _valuesHash = valuesHash(matchEntity, x, y);

    return BasicIdx_KeyTuple.getItem(_tableId, _indexesHash, _valuesHash, _index, 2);
  }

  function get(bytes32 matchEntity, int32 x, int32 y, uint256 _index) internal view returns (bytes32 entity) {
    bytes32[] memory _keyTuple = getKeyTuple(matchEntity, x, y, _index);

    matchEntity = _keyTuple[0];

    entity = _keyTuple[1];
  }

  /**
   * @notice Decode keys from a bytes32 array using the source table's field layout.
   */
  function decodeKeyTuple(bytes32[] memory _keyTuple) internal pure returns (bytes32 matchEntity, bytes32 entity) {
    matchEntity = _keyTuple[0];

    entity = _keyTuple[1];
  }
}
